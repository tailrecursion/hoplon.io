(ns io.hoplon.content.getting-started
  (:require-macros
    [bootstrap.code                :as code])
  (:require
    [io.hoplon                     :as hoplon]
    [bootstrap.grid                :as grid]
    [bootstrap.panel               :as panel]
    [bootstrap.tabs                :as tabs]
    [io.hoplon.examples.counter    :as counter]
    [io.hoplon.examples.calculator :as calc]
    [io.hoplon.examples.tabs       :as ex-tabs]
    [io.hoplon.examples.loops      :as loops]
    [io.hoplon.content.shared      :refer [hoplon-demos-url boot-url cqrs-url
                                           bootstrap-url copyright-footer]]))

(defn show [gs-task gs-tasks gs-info]
  (grid/row
    (grid/col4
      (panel/default
        :class "affix hidden-xs hidden-sm"
        (panel/heading
          (panel/title "Table of Contents"))
        (panel/body
          (grid/row
            (grid/col12
              (hoplon/table-of-contents :size 10 :toc gs-tasks))))))
    (grid/col8
      (hoplon/jump-to-toc :tocs (cell= [gs-tasks]))
      (h1
        "Getting Started" (br)
        (small "Build a Hoplon application from scratch."))
      (hr)
      (panel/default
        :class "hidden-md hidden-lg"
        (panel/heading
          (panel/title "Table of Contents"))
        (panel/body
          (grid/row
            (grid/col12
              (hoplon/table-of-contents :size 10 :toc gs-tasks)))))
      (p
        "This article will demonstrate how to build Hoplon applications.
        A simple application will be developed incrementally. New features
        will be added at each step, showing how different parts of Hoplon
        are used.")
      (br)

      (gs-info :title "System Requirements (Compiler)"
        (ul
          (li "Java 6+")
          (li "Leiningen 2")
          (li "The " (a :href boot-url :target "_blank" "boot") " build tool.")))

      (gs-info :title "Browser Compatibility"
        (ul
          (li "Chrome")
          (li "Safari")
          (li "Firefox")
          (li "Internet Explorer 8+")))

      (gs-task :title "Task 1: Create a new project."
        (p
          "The Hoplon Leiningen template can be used to create a simple
          “hello world” project:")
        (code/highlight :bash
          ;;{{
          $ lein new hoplon my-project
          ;;}}
          )
        (p
          "The directory of a new Hoplon project is:")
        (code/highlight :none
          ;;{{
          .
          ├── build.boot
          ├── README.md
          ├── assets
          │   └── css
          │       └── main.css
          └── src
              └── index.cljs.hl
          ;;}}
          )
        (p
          "If lein complains that it 'Could not find template hoplon on
          the classpath.', it may mean that you need a more recent version
          of lein. The command " (code "lein upgrade") " may help."))

      (gs-task :title "Task 2: Compile the project."
        (p "In another terminal do the following in the project directory:")
        (code/highlight :bash
          ;;{{
          $ boot development
          ;;}}
          )
        (p
          "This starts the Hoplon compiler in “development” mode – source
          directories are monitored for changes and recompiled when
          necessary. When it finished compiling the project directory
          should look like this:")
        (code/highlight :none
          ;;{{
          .
          ├── README.md
          ├── build.boot
          ├── assets
          │   └── css
          │       └── main.css
          ├── resources
          │   └── public
          │       ├── main.js
          │       ├── index.html
          │       └── css
          │           └── main.css
          └── src
          └── index.cljs.hl
          ;;}}
          )
        (p
          "Load " (code "index.html") " in a browser and enjoy a friendly
          greeting."))

      (gs-task :title "Task 3: Add a counter."
        (p
          "Now we add a counter to the page that will keep track of how
          many times a button was clicked. To do this we add an input
          cell containing the click count to the environment, and link
          it to UI elements for input and output interactions with the
          user. Input will be click events on the button. Output will
          be the contents of a text node displaying the current count.")
        (p
          "Button click events are wired up to the input cell with the "
          (code ":on-click") " attribute. The " (code "text") " macro does
          some string interpolation and wires the input cell to the value
          of a text node such that it’s updated whenever the cell’s value
          changes.")
        (p
          "Modify the " (code "index.cljs.hl") " page such that it contains
          the following:")
        (counter/code)
        (p
          "If the compiler is still running in another terminal the
          application will be recompiled. Reload the page and click the
          button a few times. You should see something like this:")
        (panel/default
          (panel/body
            (counter/demo))))

      (gs-task :title "Task 4: A simple calculator."
        (p
          "The next task is to build a simple calculator that can add,
          subtract, multiply, or divide two integers. Modify the "
          (code "index.cljs.hl") " file to contain the following:")
        (calc/code)
        (p "Compile and reload the page. You should see something like this:")
        (calc/demo)
        (p
          "Notice how the presentation (the page markup) is effectively
          decoupled from the application state (the cells). The
          four cells that contain the application's state could be
          defined in a different namespace, distributed in a jar
          file, deployed to a Maven repository, and used in a
          number of different pages. They form a well-defined API
          for the frontend developer to hook into when developing
          the page markup. This decoupling of presentation and
          state is a key component of the Hoplon model."))

      (gs-task :title "Task 5: Using the looping macro."
        (p
          "Most applications have sequential collections that need to be
          displayed to the user in some kind of template. Hoplon provides
          the " (code "loop-tpl") " macro that can be used in the page
          markup to iterate over the collection.")
        (loops/code1)
        (p "Compile and reload the page. You should see something like this:")
        (loops/ex1)
        (p
          "Note how " (code "loop-tpl") " iterates over the " (code "things")
          " cell, binding each item to " (code "x") ", in turn. However,
          notice that " (code "x") " needs to be dereferenced to be used in
          the template. This is because " (code "x") " is actually bound to
          a cell that always contains the nth item of the collection cell
          and not to the item itself.")
        (p
          "Here is a more interesting example that uses destructuring in
          the " (code ":bindings") " attribute:")
        (loops/code2)
        (p "Now when you reload the page you should see something like this:")
        (loops/ex2)
        (p
          "Notice the organization of the public API for the page’s
          underlying state machine: it consists of read-only formula cells
          and state transition functions that modify the underlying input
          cells as a side effect. This is known as the "
          (a :href cqrs-url :target "_blank" "CQRS pattern") " and forms the
          basic architecture of a Hoplon single-page app."))

      (gs-task :title "Task 6: Add static resources."
        (p
          "Now it’s time to add some static resources to the project. For
          example, adding the "
          (a :href bootstrap-url :target "_blank" "Twitter Bootstrap")
          " CSS stylesheets might help to get things looking fancy.
          If you look in " (code "build.boot") " file, you'll see that it
          contains the following:")
        (code/highlight :clj
          ;;{{
          (add-sync! (get-env :out-path) #{"assets"})
          ;;}}
          )
        (p
          "This defines the location of static assets in your project.
          Download Bootstrap and copy the " (code "bootstrap.css") " file
          into the " (code "assets/css") " directory. The project directory
          should be organized something like this now:")
        (code/highlight :none
          ;;{{
          .
          ├── build.boot
          ├── assets
          │   └── css
          │       ├── bootstrap.css
          │       └── main.css
          ├── resources
          │   └── public
          │       ├── index.html
          │       └── main.js
          └── src
          └── index.cljs.hl
          ;;}}
          )
        (p
          "Restart the compiler and see how the " (code "css") " directory
          is copied over into the output directory automatically (and
          whenever anything in there changes).")
        (p "In order to use bootstrap, the html head tag must contain a
          link to the bootstrap css file. Change " (code "(head)") " to:")
        (code/highlight :clj
          ;;{{
          (head
            (link :href "css/bootstrap.css" :rel "stylesheet"))
          ;;}}
          )
        (p
          "This is enough to bring in the bootstrap look and feel."))

      (gs-task :title "Task 7: Create a “tabs” abstraction."
        (p
          "This task demonstrates how to create a UI kit library that can be
          used in multiple pages. UI kits contain custom tags representing
          user interface abstractions. One commonly used abstraction is the
          “tabs” metaphor that everyone is familiar with.")
        (p
          "The new UI library should live in a separate namespace and
          contain custom DOM elements to use in the application pages.
          Create a new Hoplon source file, " (code "src/ui/tabs.cljs.hl")
          " with the following contents:")
        (ex-tabs/code)
        (p
          "The " (code "defelem") " macro defines a function whose arguments
          are “normalized” for the HTML markup semantic. It takes a vector
          of bindings and a number of body expressions. The bindings vector
          should bind the attribute map as the first argument and a sequence
          of children as the second. This removes the need to explicitly
          parse the arguments when the function is called in the page markup
          with key/value arguments as attributes, etc.")
        (p
          "Notice how there is no need to " (code ":refer") " any of the
          Hoplon or Javelin vars in the namespace declaration. The Hoplon
          compiler does that automatically so you can just use "
          (code "defelem") ", " (code "div") ", " (code "span") ", etc. in
          the namespace without explicitly requiring them.")
        (p
          "Then modify " (code "index.cljs.hl") " such that it looks like
          this, using the newly created " (code "tabs") " custom tag:")
        (tabs/tabs
          "index.cljs.hl"
          (ex-tabs/code2)
          "index.html.hl"
          (ex-tabs/code2h))
        (p "Compile and reload the page. You should see something like this:")
        (ex-tabs/demo))

      (gs-task :title "Castra"
        (p "The next tasks will help you to getting stated with Castra, the
          RPC library that comes with Hoplon."))

      (gs-task :title "Castra 1: Create a Castra project"
        (p
          "The hoplon-castra Leiningen template can be used to create a simple
          “hello world” project:")
        (code/highlight :bash
          ;;{{
          $ lein new hoplon-castra my-project
          ;;}}
          )
        (p
          "The directory of a new hoplon-castra project is:")
        (code/highlight :none
          ;;{{
          .
          ├── assets
          │   └── css
          │       └── main.css
          ├── build.boot
          ├── README.md
          └── src
              ├── clj
              │   └── my_project
              │       ├── api.clj
              │       └── core.clj
              ├── cljs
              │   └── my_project
              │       └── rpc.cljs
              └── hl
                  └── my_project
                      └── index.cljs.hl
          ;;}}
          ))

      (gs-task :title "Castra 2: Compile the project."
        (p "In another terminal do the following in the project directory:")
        (code/highlight :bash
          ;;{{
          $ boot development
          ;;}}
          )
        (p
          "This starts the Hoplon compiler in “development” mode — source
          directories are monitored for changes and recompiled when
          necessary. It will also start a development web server on port 8000.")
        (p
          "Go to " (a :href "http://localhost:8000" :target "_blank"
                     "http://localhost:8000")
          " in a browser and enjoy a friendly greeting. Notice the random
          numbers. They are generated on the server and the client uses Castra
          to get them."))

      (gs-task :title "Castra 3: Modifying a Castra endpoint"
        (p "Castra endpoints are functions created with a special "
          (code "defn") " from the " (code "tailrecursion.castra")
          " namespace.")
        (p "Modify the " (code "api.clj") " file such that it contains the
          following:")
        (code/highlight :clj
          ;;{{
          (ns my-project.api
            (:refer-clojure :exclude [defn])
            (:require [tailrecursion.castra :refer [defn]]))

          (def counter (atom 0))

          (defn get-state []
            {:rpc/query [{:random (rand-int 100)
                          :counter @counter}]}
            (swap! counter inc))
          ;;}}
          )
        (p "The " (code "defn") "from Castra takes a special map that works
          in a manner like the pre- and postconditions in Clojure functions.
          There is two special keys: " (code ":rpc/pre") " and "
          (code ":rpc/query") ". When " (code ":rpc/query") " is present, the
          body of the function is evaluated only for side effects — in this
          case, updating the counter. The response
          will be the content of " (code ":rpc/query") ". Like Clojure's pre-
          and postconditions, the expression needs to be inside a vector, but
          the vector is not part of the return value, only its content.")
        (p "Now the endpoint is returning a map with two keys: "
          (code ":random") " and " (code ":counter") ".
          Boot is watching those files but it doesn't autoreload
          the server files yet, so restart " (code "boot development") "to make
          the server update the response."))
      (gs-task :title "Castra 4: Update the client - Part 1"
        (p "Now we need to update the client. First change the "
          (code "rpc.cljs") " file to make it like this:")
        (code/highlight :clj
          ;;{{
          (ns my-project.rpc
            (:require-macros
              [tailrecursion.javelin :refer [defc defc=]])
            (:require
              [tailrecursion.javelin]
              [tailrecursion.castra :refer [mkremote]]))

          (defc state {:random nil})
          (defc error nil)
          (defc loading [])

          (defc= random-number (get state :random))
          (defc= counter (get state :counter))

          (def get-state
            (mkremote 'my-project.api/get-state state error loading))

          (defn init []
            (get-state)
            (js/setInterval get-state 1000))
          ;;}}
          )
        (p "This is the file that makes the communication with the server.
          It calls functions on the server like if it was just running the
          function on the client. But it really is sending a request to
          the server that send a json reponse and this response is parsed
          on the client.")
        (p "There is only one new line where we define a formula cell called "
          (code "counter") ". It will update everytime the state is updated.
          Next we will change the page so we can see the counter.")
        (p "Also take a look at the " (code "mkremote") "function. You call
          it with a quoted namespaced function and three cells: one for the
          state, one for errors and one to indicate a call in progress. So,
          if the function call succeeds the state is updated. If it errors,
          the error cell is updated. And while a call is in progress the
          loading cell will not be empty."))
      (gs-task :title "Castra 5: Update the client - Part 2"
        (p "Change the " (code "index.cljs.hl") " file:")
        (code/highlight :clj
          ;;{{
          (page "index.html"
            (:require [my-project.rpc :as rpc]))

          (rpc/init)

          (html
            (head
              (link :rel "stylesheet" :type "text/css" :href "css/main.css"))
            (body
              (h1 (text "Hello, Hoplon and Castra! ~{rpc/random-number}"))
              (p (text "Look! It's a counter: ~{rpc/counter}"))))
          ;;}}
          )
        (p "Here we added a " (code "p") " tag with a " (code "text") "macro
          that will update everytime the cell updates. Reload the page and
          you will see the random numbers and your new counter.
          Congratulations!"))
      (gs-task :title "Learn more"
        (p "You take a look at some documentation on the "
          (a :href "#/docs/" "docs section") " and there are some example
          projects on " (a :href hoplon-demos-url "Hoplon demos") ". There
          are also some tutorials on the "
          (a :href "#/talks/" "talking Hoplon section")))

      (hr)
      (copyright-footer))))
